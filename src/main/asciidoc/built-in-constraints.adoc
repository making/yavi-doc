[[built-in-constraints]]
== Built-in Constraints

YAVI includes many commonly used built-in constraints for various types.

=== String

Apply the constraints on the `String` as follows:

[source,java]
----
Validator<TargetClass> validator = ValidatorBuilder.<TargetClass> of()
        .constraints(/* Function from TargetClass to String  */, /* Field Name */, /* Constraints */)
        .build();
----

To avoid ambiguous type inferences, you can use explicit `_string` instead of `constraints` as follows:

[source,java]
----
Validator<TargetClass> validator = ValidatorBuilder.<TargetClass> of()
        ._string(/* Function from TargetClass to String  */, /* Field Name */, /* Constraints */)
        .build();
----

If you want to apply constraints to the more generic `CharSequence`, use `_charSequence` method.

[source,java]
----
Validator<TargetClass> validator = ValidatorBuilder.<TargetClass> of()
        ._charSequence(/* Function from TargetClass to CharSequence  */, /* Field Name */, /* Constraints */)
        .build();
----

==== `notNull()`

Checks that the target value is not `null`

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.notNull())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Invalid ("email" must not be null)
----

|===
|Message Key |Default Message Format |Args

|`object.notNull`
|`"{0}" must not be null`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `notEmpty()`

Checks whether the target value is not `null` nor empty

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.notEmpty())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Invalid ("email" must not be empty)
ConstraintViolations violations = validator.validate(new Email("")); // Invalid ("email" must not be empty)
----

|===
|Message Key |Default Message Format |Args

|`container.notEmpty`
|`"{0}" must not be empty`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `notBlank()`

Checks that the target value is not `null`, and the trimmed userId is greater than `0`.
The difference to `notEmpty()` is that trailing white-spaces are ignored.

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.notBlank())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Invalid ("email" must not be blank)
ConstraintViolations violations = validator.validate(new Email(" ")); // Invalid ("email" must not be blank)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.notBlank`
|`"{0}" must not be blank`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `fixedSize(int)`

Checks if the target value's size is the specified size

[source,java]
----
Validator<ZipCode> validator = ValidatorBuilder.<ZipCode> of()
        .constraints(ZipCode::value, "zipCode", c -> c.fixedSize(7))
        .build();

ConstraintViolations violations = validator.validate(new ZipCode("1234567")); // Valid
ConstraintViolations violations = validator.validate(new ZipCode(null)); // Valid
ConstraintViolations violations = validator.validate(new ZipCode("123-4567")); // Invalid (The size of "zipCode" must be 7. The given size is 8)
----

|===
|Message Key |Default Message Format |Args

|`container.fixedSize`
|`The size of "{0}" must be {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `greaterThan(int)`

Checks if the target value's size is greater than the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.greaterThan(2))
        .build();

ConstraintViolations violations = validator.validate(new Country("Japan")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("J")); // Invalid (The size of "country" must be greater than 2. The given size is 1)
----

|===
|Message Key |Default Message Format |Args

|`container.greaterThan`
|`The size of "{0}" must be greater than {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `greaterThanOrEqual(int)`

Checks if the target value's size is greater than or equals to the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.greaterThanOrEqual(2))
        .build();

ConstraintViolations violations = validator.validate(new Country("Japan")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("J")); // Invalid (The size of "country" must be greater than or equal to 2. The given size is 1)
----

|===
|Message Key |Default Message Format |Args

|`container.greaterThanOrEqual`
|`The size of "{0}" must be greater than or equal to {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `lessThan(int)`

Checks if the target value's size is less than the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.lessThan(4))
        .build();

ConstraintViolations violations = validator.validate(new Country("JP")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("Japan")); // Invalid (The size of "country" must be less than 4. The given size is 5)
----

|===
|Message Key |Default Message Format |Args

|`container.lessThan`
|`The size of "{0}" must be less than {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `lessThanOrEqual(int)`

Checks if the target value's size is less than or equals to the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.lessThanOrEqual(4))
        .build();

ConstraintViolations violations = validator.validate(new Country("JP")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("Japan")); // Invalid (The size of "country" must be less than or equal to to 4. The given size is 5)
----

|===
|Message Key |Default Message Format |Args

|`container.lessThanOrEqual`
|`The size of "{0}" must be less than or equal to {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `contains(CharSequence)`

Checks if the target value contains the specified sequence of char values

[source,java]
----
Validator<ZipCode> validator = ValidatorBuilder.<ZipCode> of()
        .constraints(ZipCode::value, "zipCode", c -> c.contains("-"))
        .build();

ConstraintViolations violations = validator.validate(new ZipCode("123-4567")); // Valid
ConstraintViolations violations = validator.validate(new ZipCode(null)); // Valid
ConstraintViolations violations = validator.validate(new ZipCode("1234567")); // Invalid ("zipCode" must contain -)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.contains`
|`"{0}" must contain {1}`
a|
* `{0}` ... field name
* `{1}` ... the specified char sequence
* `{2}` ... the given value
|===

==== `pattern(String)`

Checks if the target value matches the specified regular expression

[source,java]
----
Validator<ZipCode> validator = ValidatorBuilder.<ZipCode> of()
        .constraints(ZipCode::value, "zipCode", c -> c.pattern("[0-9]{3}-[0-9]{4}"))
        .build();

ConstraintViolations violations = validator.validate(new ZipCode("123-4567")); // Valid
ConstraintViolations violations = validator.validate(new ZipCode(null)); // Valid
ConstraintViolations violations = validator.validate(new ZipCode("1234567")); // Invalid ("zipCode" must match [0-9]{3}-[0-9]{4})
----

|===
|Message Key |Default Message Format |Args

|`charSequence.pattern`
|`"{0}" must match {1}`
a|
* `{0}` ... field name
* `{1}` ... the specified regular expression
* `{2}` ... the given value
|===

==== `email()`

Checks if the target value is a valid email address

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.email())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Valid
ConstraintViolations violations = validator.validate(new Email("example.com")); // Invalid ("email" must not be a valid email address)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.email`
|`"{0}" must match {1}`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `password(...)`

Check if the target value meets the specified password policy

[source,java]
----
Validator<Password> validator = ValidatorBuilder.<Password>of()
		.constraint(Password::value, "password", c -> c.password(policy -> policy
				.uppercase()
				.lowercase()
				// or .required(PasswordPolicy.UPPERCASE, PasswordPolicy.LOWERCASE)
				.optional(1, PasswordPolicy.NUMBERS, PasswordPolicy.SYMBOLS)
				.build()))
		.build();

ConstraintViolations violations = validator.validate(new Password("Yavi123")); // Valid
ConstraintViolations violations = validator.validate(new Password(null)); // Valid
ConstraintViolations violations = validator.validate(new Password("yavi123")); // Invalid ("password" must contain Uppercase policy)
ConstraintViolations violations = validator.validate(new Password("yavi")); // Invalid ("password" must contain Uppercase policy, "password" must contain at least 1 policies from [Numbers, Symbols])
ConstraintViolations violations = validator.validate(new Password("")); // Invalid ("password" must contain Uppercase policy, "password" must contain Lowercase policy, "password" must contain at least 1 policies from [Numbers, Symbols])
----

|===
|Message Key |Default Message Format |Args

|`charSequence.passwordRequired`
|`"{0}" must contain {1} policy`
a|
* `{0}` ... field name
* `{1}` ... the specified policy name
* `{2}` ... the given value
|`charSequence.passwordOptional`
|`"{0}" must contain at least {1} policies from {2}`
a|
* `{0}` ... field name
* `{1}` ... minimum requirement
* `{2}` ... the specified policy names
* `{3}` ... the given value
|===

Buit-in password policies are following:

* `am.ik.yavi.constraint.password.PasswordPolicy#UPPERCASE`
* `am.ik.yavi.constraint.password.PasswordPolicy#LOWERCASE`
* `am.ik.yavi.constraint.password.PasswordPolicy#NUMBERS`
* `am.ik.yavi.constraint.password.PasswordPolicy#SYMBOLS`

You can define a custom password policy as bellow:

[source,java]
----
PasswordPolicy<String> passwordPolicy = new PasswordPolicy<>() {
	@Override
	public String name() {
		return "DoNotIncludePassword";
	}

	@Override
	public boolean test(String s) {
		return !s.equalsIgnoreCase("password");
	}
};


Validator<Password> validator = ValidatorBuilder.<Password>of()
		.constraint(Password::value, "password", c -> c.password(policy -> policy
				.required(passwordPolicy)
				// ...
				.build()))
		.build();
----

==== `ipv4()`

Check if the target value is a valid IPv4 address

[source,java]
----
Validator<IpAddress> validator = ValidatorBuilder.<IpAddress> of()
        .constraints(IpAddress::value, "ipAddress", c -> c.ipv4())
        .build();

ConstraintViolations violations = validator.validate(new IpAddress("192.0.2.1")); // Valid
ConstraintViolations violations = validator.validate(new IpAddress(null)); // Valid
ConstraintViolations violations = validator.validate(new IpAddress("example.com")); // Invalid ("ipAddress" must not be a valid IPv4)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.ipv4`
|`"{0}" must be a valid IPv4`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `ipv6()`

Check if the target value is a valid IPv6 address

[source,java]
----
Validator<IpAddress> validator = ValidatorBuilder.<IpAddress> of()
        .constraints(IpAddress::value, "ipAddress", c -> c.ipv6())
        .build();

ConstraintViolations violations = validator.validate(new IpAddress("2001:0db8:bd05:01d2:288a:1fc0:0001:10ee")); // Valid
ConstraintViolations violations = validator.validate(new IpAddress(null)); // Valid
ConstraintViolations violations = validator.validate(new IpAddress("192.0.2.1")); // Invalid ("ipAddress" must not be a valid IPv6)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.ipv6`
|`"{0}" must be a valid IPv6`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `url()`

Check if the target value is a valid URL

[source,java]
----
Validator<Url> validator = ValidatorBuilder.<Url> of()
        .constraints(Url::value, "url", c -> c.url())
        .build();

ConstraintViolations violations = validator.validate(new Url("https://yavi.ik.am")); // Valid
ConstraintViolations violations = validator.validate(new Url(null)); // Valid
ConstraintViolations violations = validator.validate(new Url("yavi.ik.am")); // Invalid ("url" must be a valid URL)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.url`
|`"{0}" must be a valid URL`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `luhn()`

Checks if the digits within the target value pass the Luhn checksum algorithm (see also http://en.wikipedia.org/wiki/Luhn_algorithm[Luhn algorithm]).

[source,java]
----
Validator<CreditCard> validator = ValidatorBuilder.<CreditCard> of()
        .constraints(CreditCard::number, "creditCardNumber", c -> c.luhn())
        .build();

ConstraintViolations violations = validator.validate(new CreditCard("4111111111111111")); // Valid
ConstraintViolations violations = validator.validate(new CreditCard(null)); // Valid
ConstraintViolations violations = validator.validate(new CreditCard("4111111111111112")); // Invalid (the check digit for "creditCardNumber" is invalid, Luhn checksum failed)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.luhn`
|`the check digit for "{0}" is invalid, Luhn checksum failed`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isByte()`

Check if the target value can be parsed as a `Byte` value

[source,java]
----
Validator<UserId> validator = ValidatorBuilder.<UserId> of()
        .constraints(UserId::value, "userId", c -> c.isByte())
        .build();

ConstraintViolations violations = validator.validate(UserId.valueOf("127")); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf("a")); // Invalid ("userId" must be a valid representation of a byte)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.byte`
|`"{0}" must be a valid representation of a byte`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isShort()`

Check if the target value can be parsed as a `Short` value

[source,java]
----
Validator<UserId> validator = ValidatorBuilder.<UserId> of()
        .constraints(UserId::value, "userId", c -> c.isShort())
        .build();

ConstraintViolations violations = validator.validate(UserId.valueOf("32767")); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf("a")); // Invalid ("userId" must be a valid representation of a short)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.short`
|`"{0}" must be a valid representation of a short`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isInteger()`

Check if the target value can be parsed as an `Integer` value

[source,java]
----
Validator<UserId> validator = ValidatorBuilder.<UserId> of()
        .constraints(UserId::value, "userId", c -> c.isInteger())
        .build();

ConstraintViolations violations = validator.validate(UserId.valueOf("2147483647")); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf("a")); // Invalid ("userId" must be a valid representation of an integer)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.integer`
|`"{0}" must be a valid representation of an integer`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isLong()`

Check if the target value can be parsed as a `Long` value

[source,java]
----
Validator<UserId> validator = ValidatorBuilder.<UserId> of()
        .constraints(UserId::value, "userId", c -> c.isLong())
        .build();

ConstraintViolations violations = validator.validate(UserId.valueOf("9223372036854775807")); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf("a")); // Invalid ("userId" must be a valid representation of a long)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.long`
|`"{0}" must be a valid representation of a long`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isFloat()`

Check if the target value can be parsed as a `Float` value

[source,java]
----
Validator<Money> validator = ValidatorBuilder.<Money> of()
        .constraints(Money::value, "money", c -> c.isFloat())
        .build();

ConstraintViolations violations = validator.validate(Money.valueOf("0.1")); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf("a")); // Invalid ("money" must be a valid representation of a float)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.float`
|`"{0}" must be a valid representation of a float.`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isDouble()`

Check if the target value can be parsed as a `Double` value

[source,java]
----
Validator<Money> validator = ValidatorBuilder.<Money> of()
        .constraints(Money::value, "money", c -> c.isDouble())
        .build();

ConstraintViolations violations = validator.validate(Money.valueOf("0.1")); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf("a")); // Invalid ("money" must be a valid representation of a double)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.double`
|`"{0}" must be a valid representation of a double`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isBigInteger()`

Check if the target value can be parsed as a `BigInteger` value

[source,java]
----
Validator<UserId> validator = ValidatorBuilder.<UserId> of()
        .constraints(UserId::value, "userId", c -> c.isBigInteger())
        .build();

ConstraintViolations violations = validator.validate(UserId.valueOf("127")); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf("a")); // Invalid ("userId" must be a valid representation of a big integer)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.bigInteger`
|`"{0}" must be a valid representation of a big integer`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isBigDecimal()`

Check if the target value can be parsed as a `BigDecimal` value

[source,java]
----
Validator<Money> validator = ValidatorBuilder.<Money> of()
        .constraints(Money::value, "money", c -> c.isBigDecimal())
        .build();

ConstraintViolations violations = validator.validate(Money.valueOf("50.0")); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf("a")); // Invalid ("money" must be a valid representation of a big decimal)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.bigDecimal`
|`"{0}" must be a valid representation of a big decimal`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `codePoints(...)`

Checks if the target value is in the specified set of code points.
Code points can be specified as allowed characters (whitelist) or prohibited characters (blacklist).

A set of code points is represented by `am.ik.yavi.constraint.charsequence.CodePoints` interface, and there is `am.ik.yavi.constraint.charsequence.CodePoints.CodePointsSet` interface that represents the set using `java.util.Set` and `am.ik.yavi.constraint.charsequence.CodePoints.CodePointsRanges` interface that represents a list of code point ranges.

For example, a code point set consisting of "A, B, C, D, a, b, c, d" is expressed as follows:

[source,java]
----
CodePointsSet<String> codePoints = () -> new HashSet<>(
        Arrays.asList(0x0041 /* A */, 0x0042 /* B */, 0x0043 /* C */, 0x0044 /* D */,
                0x0061 /* a */, 0x0062 /* b */, 0x0063 /* c */, 0x0064 /* d */));
----

Or:

[source,java]
----
CodePointsRanges<String> codePoints = () -> Arrays.asList(
        Range.of(0x0041/* A */, 0x0044 /* D */),
        Range.of(0x0061/* a */, 0x0064 /* d */));
----

For consecutive code points, the latter is overwhelmingly more memory efficient.

If you want to regard the code point set as a white list (allowed characters), specify as follows:

[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
        .constraint(Message::getText, "text", c -> c.codePoints(codePoints).asWhiteList())
        .build();

ConstraintViolations violations = validator.validate(new Message("aBCd")); // Valid
ConstraintViolations violations = validator.validate(new Message(null)); // Valid
ConstraintViolations violations = validator.validate(new Message("aBCe")); // Invalid ("[e]" is/are not allowed for "text")
----

If you want to regard the code point set as a blacklist (prohibited characters), specify as follows:

[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
        .constraint(Message::getText, "text", c -> c.codePoints(codePoints).asBlackList())
        .build();

ConstraintViolations violations = validator.validate(new Message("hello")); // Valid
ConstraintViolations violations = validator.validate(new Message(null)); // Valid
ConstraintViolations violations = validator.validate(new Message("hallo")); // Invalid ("[a]" is/are not allowed for "text")
----

|===
|Message Key |Default Message Format |Args

|`codePoints.asWhiteList`
|`"{1}" is/are not allowed for "{0}"`
a|
* `{0}` ... field name
* `{1}` ... the violated value
|`codePoints.asBlackList`
|`"{1}" is/are not allowed for "{0}"`
a|
* `{0}` ... field name
* `{1}` ... the violated value
|===

The following is a set of built-in code points.

* `am.ik.yavi.constraint.charsequence.codepoints.AsciiCodePoints#ASCII_PRINTABLE_CHARS` ... ASCII printable characters
* `am.ik.yavi.constraint.charsequence.codepoints.AsciiCodePoints#ASCII_CONTROL_CHARS` ... ASCII control characters
* `am.ik.yavi.constraint.charsequence.codepoints.AsciiCodePoints#CRLF` ... `0x000A` (LINE FEED) and `0x000D` (CARRIAGE RETURN)
* `am.ik.yavi.constraint.charsequence.codepoints.UnicodeCodePoints#HIRAGANA` ... https://www.unicode.org/charts/nameslist/c_3040.html[Hiragana] defined in Unicode (different from JIS X 0208 definition)
* `am.ik.yavi.constraint.charsequence.codepoints.UnicodeCodePoints#KATAKANA` ... https://www.unicode.org/charts/nameslist/c_30A0.html[Katakana] and https://www.unicode.org/charts/nameslist/c_31F0.html[Katakana Phonetic Extensions] defined in Unicode (different from JIS X 0208 definition)

You can also represent the union of multiple code point sets with `am.ik.yavi.constraint.charsequence.codepoints.CompositeCodePoints` class.

==== Advanced character length check

YAVI counts the input characters as the number of characters as it looks in the constraints on the number of characters. Recently, as a result of defining various characters on Unicode, the visual size and the return value of `String#length` method are quite different.

YAVI supports the following character types:

* Surrogate pair
* Combining character
* Variation Selector
** IVS (Ideographic Variation Sequence)
** SVS (Standardized Variation Sequence)
** FVS (Mongolian Free Variation Selector)
* Emoji

YAVI will perform a constraint check on surrogate pairs and combining characters with the number of characters as they look. (For Emoji, IVS, SVS and FVS, the size is not checked as it looks by default due to the performance.)

Let's look at a typical example.

===== Surrogate pair

`𠮷野屋` is an example of a surrogate pair. It looks like 3 characters, but the result of `length` method is 4 (`\uD842\uDFB7野屋`).

[source,java]
----
System.out.println("𠮷野屋".length()); // 4 (\uD842\uDFB7野屋)
----

Since YAVI treats the character length as the code point length, this character string is regarded as 3 characters.

[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
        .constraint(Message::getText, "text", c -> c.lessThanOrEqual(3))
        .build();

ConstraintViolations = validator.validate(new Message("𠮷野屋")); // Valid
----

===== Combining character

`モジ` is an example of a combining character. Although it looks like 2 characters, `シ` and dakuten(`゙`) are combined, and the result of `length()` is 3 (`モシ\u3099`).

[source,java]
----
System.out.println("モジ".length()); // 3 (モシ\u3099)
----

YAVI considers this string to be 2 characters by default.

[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
        .constraint(Message::getText, "text", c -> c.lessThanOrEqual(2))
        .build();

ConstraintViolations = validator.validate(new Message("モジ")); // Valid
----

YAVI uses `java.text.Normalizer` and normalizes with `java.text.Normalizer.Form#NFC` by default. This behavior can be changed as follows: (If `null` is set, it will not be normalized)

[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
        .constraint(Message::getText, "text", c -> c.normalizer(normalizerForm)
				.lessThanOrEqual(2))
        .build();
----

===== Variation Selector

`𠮟󠄀` is an example of an Ideographic Variation Sequence. Variant selectors cannot be normalized with `Normalizer`.
It looks like 1 character, but when expressed in UTF-16, it is "D842 DF9F DB40 DD00", so the result of `length()` is 4.

[source,java]
----
System.out.println("𠮟󠄀".length()); // 4 (\uD842\uDF9F\uDB40\uDD00󠄀)
----

YAVI does *not* consider this character as a single character by default to prevent performance degradation.

[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
		.constraint(Message::getText, "text", c -> c.lessThanOrEqual(1))
		.build();
ConstraintViolations = validator.validate(new Message("𠮟󠄀")); // Invalid (The size of "text" must be less than or equal to 1. The given size is 2)
----

You can ignore (delete) the code point of `0xE0100`-`0xE01EF`, which is the range of IVS from the target string, as follows.
This way you can regard this string as just a surrogate pair.

[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
		.constraint(Message::getText, "text", c -> c.variant(opts -> opts.ivs(IdeographicVariationSequence.IGNORE))
				.lessThanOrEqual(1))
		.build();
ConstraintViolations = validator.validate(new Message("𠮟󠄀")); // Valid
----

SVS and FVS can be handled in the same way.

===== Emoji

Emoji is crazy. The apparent number of characters and the number of code points are far away.

Let me give you examples.

[source,java]
----
System.out.println("❤️".length()); // 2
System.out.println("🤴🏻".length()); // 4
System.out.println("👨‍👦".length()); // 5
System.out.println("️👨‍👨‍👧‍👦".length()); // 12
System.out.println("🏴󠁧󠁢󠁥󠁮󠁧󠁿".length()); // 14 (WTH!)
----

YAVI can try to count these Emojis as one character as much as possible. There is no guarantee, but all emojis defined in Emoji 12.0 have been tested.

This process is expensive and is *not* enabled by default. To enable this feature, specify the `emoji()` method as follows:

[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
        .constraint(Message::getText, "text", c -> c.emoji().lessThanOrEqual(1))
        .build();
ConstraintViolations = validator.validate(new Message("❤️")); // Valid
ConstraintViolations = validator.validate(new Message("🤴🏻")); // Valid
ConstraintViolations = validator.validate(new Message("👨‍👦")); // Valid
ConstraintViolations = validator.validate(new Message("️👨‍👨‍👧‍👦")); // Valid
ConstraintViolations = validator.validate(new Message("🏴󠁧󠁢󠁥󠁮󠁧󠁿")); // Valid
----


==== `asByteArray()`

If there is a discrepancy between the apparent character length and the actual code point length, the appearance restrictions are OK, but the size stored in the database may be exceeded. In YAVI, you can check the byte length in addition to the visual size.


[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
        .constraint(Message::getText, "text", c -> c.emoji().lessThanOrEqual(3)
                .asByteArray().lessThanOrEqual(16))
        .build();

ConstraintViolations = validator.validate(new Message("I❤️☕️️")); // Valid
ConstraintViolations = validator.validate(new Message("❤️❤️❤️️️")); // Invalid (The byte size of "text" must be less than or equal to 16. The given size is 24)
----

|===
|Message Key |Default Message Format |Args

|`byteSize.lessThan`
|`The byte size of "{0}" must be less than {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|`byteSize.lessThanOrEqual`
|`The byte size of "{0}" must be less than or equal to {1}. The given size is {2}"`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|`byteSize.greaterThan`
|`The byte size of "{0}" must be greater than {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|`byteSize.greaterThanOrEqual`
|`The byte size of "{0}" must be greater than or equal to {1}. The given size is {2}"`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|`byteSize.fixedSize`
|`The byte size of "{0}" must be {1}. The given size is {2}"`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

=== Integer/Short/Long/Character/Byte/Float/Long/BigInteger/BigDecimal

Apply the constraints on the `Integer` as follows:

[source,java]
----
Validator<TargetClass> validator = ValidatorBuilder.<TargetClass> of()
        .constraints(/* Function from TargetClass to Integer  */, /* Field Name */, /* Constraints */)
        .build();
----

To avoid ambiguous type inferences, you can use explicit `_integer` instead of `constraints` as follows:

[source,java]
----
Validator<TargetClass> validator = ValidatorBuilder.<TargetClass> of()
        ._integer(/* Function from TargetClass to Integer  */, /* Field Name */, /* Constraints */)
        .build();
----

The same goes for `Short`/`Long`/`Character`/`Byte`/`Float`/`Long` / `BigInteger` / `BigDecimal`.

==== `notNull()`

Checks that the target value is not `null`

[source,java]
----
Validator<Age> validator = ValidatorBuilder.<Age> of()
        .constraints(Age::value, "age", c -> c.notNull())
        .build();

ConstraintViolations violations = validator.validate(new Age(30)); // Valid
ConstraintViolations violations = validator.validate(new Age(null)); // Invalid ("age" must not be null)
----

|===
|Message Key |Default Message Format |Args

|`object.notNull`
|`"{0}" must not be null`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `greaterThan(...)`

Checks if the target value is greater than the specified value

[source,java]
----
Validator<Age> validator = ValidatorBuilder.<Age> of()
        .constraints(Age::value, "age", c -> c.greaterThan(20))
        .build();

ConstraintViolations violations = validator.validate(new Age(21)); // Valid
ConstraintViolations violations = validator.validate(new Age(null)); // Valid
ConstraintViolations violations = validator.validate(new Age(20)); // Invalid ("age" must be greater than 20)
----

|===
|Message Key |Default Message Format |Args

|`numeric.greaterThan`
|`"{0}" must be greater than {1}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given value
|===

==== `greaterThanOrEqual(...)`

Checks if the target value is greater than or equals to the specified value

[source,java]
----
Validator<Age> validator = ValidatorBuilder.<Age> of()
        .constraints(Age::value, "age", c -> c.greaterThanOrEqual(20))
        .build();

ConstraintViolations violations = validator.validate(new Age(20)); // Valid
ConstraintViolations violations = validator.validate(new Age(null)); // Valid
ConstraintViolations violations = validator.validate(new Age(19)); // Invalid ("age" must be greater than or equal to 10)
----

|===
|Message Key |Default Message Format |Args

|`numeric.greaterThan`
|`"{0}" must be greater than or equal to {1}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given value
|===

==== `lessThan(...)`

Checks if the target value is less than the specified value

[source,java]
----
Validator<Age> validator = ValidatorBuilder.<Age> of()
        .constraints(Age::value, "age", c -> c.lessThan(20))
        .build();

ConstraintViolations violations = validator.validate(new Age(19)); // Valid
ConstraintViolations violations = validator.validate(new Age(null)); // Valid
ConstraintViolations violations = validator.validate(new Age(20)); // Invalid ("age" must be less than 20)
----

|===
|Message Key |Default Message Format |Args

|`numeric.lessThan`
|`"{0}" must be less than {1}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given value
|===

==== `lessThanOrEqual(...)`

Checks if the target value is less than or equals to the specified value

[source,java]
----
Validator<Age> validator = ValidatorBuilder.<Age> of()
        .constraints(Age::value, "age", c -> c.lessThanOrEqual(20))
        .build();

ConstraintViolations violations = validator.validate(new Age(19)); // Valid
ConstraintViolations violations = validator.validate(new Age(null)); // Valid
ConstraintViolations violations = validator.validate(new Age(21)); // Invalid ("age" must be less than or equal to 10)
----

|===
|Message Key |Default Message Format |Args

|`numeric.lessThan`
|`"{0}" must be less than or equal to {1}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given value
|===

=== Boolean

Apply the constraints on the `Boolean` as follows:

[source,java]
----
Validator<TargetClass> validator = ValidatorBuilder.<TargetClass> of()
        .constraints(/* Function from TargetClass to Boolean  */, /* Field Name */, /* Constraints */)
        .build();
----

To avoid ambiguous type inferences, you can use explicit `_boolean` instead of `constraints` as follows:

[source,java]
----
Validator<TargetClass> validator = ValidatorBuilder.<TargetClass> of()
        ._boolean(/* Function from TargetClass to Boolean  */, /* Field Name */, /* Constraints */)
        .build();
----

=== Object

==== `notNull()`

Checks that the target value is not `null`

[source,java]
----
Validator<Confirmation> validator = ValidatorBuilder.<Confirmation> of()
        .constraints(Confirmation::isConfirmed, "confirmed", c -> c.notNull())
        .build();

ConstraintViolations violations = validator.validate(new Confirmation(true)); // Valid
ConstraintViolations violations = validator.validate(new Confirmation(null)); // Invalid ("confirmed" must not be null)
----

|===
|Message Key |Default Message Format |Args

|`object.notNull`
|`"{0}" must not be null`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isTrue()`

Checks that the target value is `true`

[source,java]
----
Validator<Confirmation> validator = ValidatorBuilder.<Confirmation> of()
        .constraints(Confirmation::isConfirmed, "confirmed", c -> c.isTrue())
        .build();

ConstraintViolations violations = validator.validate(new Confirmation(true)); // Valid
ConstraintViolations violations = validator.validate(new Confirmation(null)); // Valid
ConstraintViolations violations = validator.validate(new Confirmation(false)); // Invalid ("confirmed" must be true)
----

|===
|Message Key |Default Message Format |Args

|`boolean.isTrue`
|`"{0}" must be true`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===


==== `isFalse()`

Checks that the target value is `false`

[source,java]
----
Validator<Rented> validator = ValidatorBuilder.<Rented> of()
        .constraints(Rented::isRented, "rented", c -> c.isFalse())
        .build();

ConstraintViolations violations = validator.validate(new Rented(false)); // Valid
ConstraintViolations violations = validator.validate(new Rented(null)); // Valid
ConstraintViolations violations = validator.validate(new Rented(true)); // Invalid ("rented" must be false)
----

|===
|Message Key |Default Message Format |Args

|`boolean.isFalse`
|`"{0}" must be false`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

=== List/Array/Map