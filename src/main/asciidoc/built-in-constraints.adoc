[[built-in-constraints]]
== Built-in Constraints

YAVI includes many commonly used built-in constraints for various types.

=== String

Apply the constraints on the `String` as follows:

[source,java]
----
Validator<TargetClass> validator = ValidatorBuilder.<TargetClass> of()
        .constraints(/* Function from TargetClass to String  */, /* Field Name */, /* Constraints */)
        .build();
----

To avoid ambiguous type inferences, you can use explicit `_string` instead of `constraints` as follows:

[source,java]
----
Validator<TargetClass> validator = ValidatorBuilder.<TargetClass> of()
        ._string(/* Function from TargetClass to String  */, /* Field Name */, /* Constraints */)
        .build();
----

If you want to apply constraints to the more generic `CharSequence`, use `_charSequence` method.

[source,java]
----
Validator<TargetClass> validator = ValidatorBuilder.<TargetClass> of()
        ._charSequence(/* Function from TargetClass to CharSequence  */, /* Field Name */, /* Constraints */)
        .build();
----

==== `notNull()`

Checks that the target value is not `null`

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.notNull())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Invalid ("email" must not be null)
----

|===
|Message Key |Default Message Format |Args

|`object.notNull`
|`"{0}" must not be null`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `notEmpty()`

Checks whether the target value is not `null` nor empty

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.notEmpty())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Invalid ("email" must not be empty)
ConstraintViolations violations = validator.validate(new Email("")); // Invalid ("email" must not be empty)
----

|===
|Message Key |Default Message Format |Args

|`container.notEmpty`
|`"{0}" must not be empty`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `notBlank()`

Checks that the target value is not `null`, and the trimmed userId is greater than `0`.
The difference to `notEmpty()` is that trailing white-spaces are ignored.

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.notBlank())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Invalid ("email" must not be blank)
ConstraintViolations violations = validator.validate(new Email(" ")); // Invalid ("email" must not be blank)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.notBlank`
|`"{0}" must not be blank`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `fixedSize(int)`

Checks if the target value's size is the specified size

[source,java]
----
Validator<ZipCode> validator = ValidatorBuilder.<ZipCode> of()
        .constraints(ZipCode::value, "zipCode", c -> c.fixedSize(7))
        .build();

ConstraintViolations violations = validator.validate(new ZipCode("1234567")); // Valid
ConstraintViolations violations = validator.validate(new ZipCode(null)); // Valid
ConstraintViolations violations = validator.validate(new ZipCode("123-4567")); // Invalid (The size of "zipCode" must be 7. The given size is 8)
----

|===
|Message Key |Default Message Format |Args

|`container.fixedSize`
|`The size of "{0}" must be {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `greaterThan(int)`

Checks if the target value's size is greater than the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.greaterThan(2))
        .build();

ConstraintViolations violations = validator.validate(new Country("Japan")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("J")); // Invalid (The size of "country" must be greater than 2. The given size is 1)
----

|===
|Message Key |Default Message Format |Args

|`container.greaterThan`
|`The size of "{0}" must be greater than {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `greaterThanOrEqual(int)`

Checks if the target value's size is greater than or equals to the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.greaterThanOrEqual(2))
        .build();

ConstraintViolations violations = validator.validate(new Country("Japan")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("J")); // Invalid (The size of "country" must be greater than or equal to 2. The given size is 1)
----

|===
|Message Key |Default Message Format |Args

|`container.greaterThanOrEqual`
|`The size of "{0}" must be greater than or equal to {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `lessThan(int)`

Checks if the target value's size is less than the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.lessThan(4))
        .build();

ConstraintViolations violations = validator.validate(new Country("JP")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("Japan")); // Invalid (The size of "country" must be less than 4. The given size is 5)
----

|===
|Message Key |Default Message Format |Args

|`container.lessThan`
|`The size of "{0}" must be less than {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `lessThanOrEqual(int)`

Checks if the target value's size is less than or equals to the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.lessThanOrEqual(4))
        .build();

ConstraintViolations violations = validator.validate(new Country("JP")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("Japan")); // Invalid (The size of "country" must be less than or equal to to 4. The given size is 5)
----

|===
|Message Key |Default Message Format |Args

|`container.lessThanOrEqual`
|`The size of "{0}" must be less than or equal to {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `contains(CharSequence)`

Checks if the target value contains the specified sequence of char values

[source,java]
----
Validator<ZipCode> validator = ValidatorBuilder.<ZipCode> of()
        .constraints(ZipCode::value, "zipCode", c -> c.contains("-"))
        .build();

ConstraintViolations violations = validator.validate(new ZipCode("123-4567")); // Valid
ConstraintViolations violations = validator.validate(new ZipCode(null)); // Valid
ConstraintViolations violations = validator.validate(new ZipCode("1234567")); // Invalid ("zipCode" must contain -)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.contains`
|`"{0}" must contain {1}`
a|
* `{0}` ... field name
* `{1}` ... the specified char sequence
* `{2}` ... the given value
|===

==== `pattern(String)`

Checks if the target value matches the specified regular expression

[source,java]
----
Validator<ZipCode> validator = ValidatorBuilder.<ZipCode> of()
        .constraints(ZipCode::value, "zipCode", c -> c.pattern("[0-9]{3}-[0-9]{4}"))
        .build();

ConstraintViolations violations = validator.validate(new ZipCode("123-4567")); // Valid
ConstraintViolations violations = validator.validate(new ZipCode(null)); // Valid
ConstraintViolations violations = validator.validate(new ZipCode("1234567")); // Invalid ("zipCode" must match [0-9]{3}-[0-9]{4})
----

|===
|Message Key |Default Message Format |Args

|`charSequence.pattern`
|`"{0}" must match {1}`
a|
* `{0}` ... field name
* `{1}` ... the specified regular expression
* `{2}` ... the given value
|===

==== `email()`

Checks if the target value is a valid email address

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.email())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Valid
ConstraintViolations violations = validator.validate(new Email("example.com")); // Invalid ("email" must not be a valid email address)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.email`
|`"{0}" must match {1}`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `password(...)`

Check if the target value meets the specified password policy

[source,java]
----
Validator<Password> validator = ValidatorBuilder.<Password>of()
		.constraint(Password::value, "password", c -> c.password(policy -> policy
				.uppercase()
				.lowercase()
				// or .required(PasswordPolicy.UPPERCASE, PasswordPolicy.LOWERCASE)
				.optional(1, PasswordPolicy.NUMBERS, PasswordPolicy.SYMBOLS)
				.build()))
		.build();

ConstraintViolations violations = validator.validate(new Password("Yavi123")); // Valid
ConstraintViolations violations = validator.validate(new Password(null)); // Valid
ConstraintViolations violations = validator.validate(new Password("yavi123")); // Invalid ("password" must contain Uppercase policy)
ConstraintViolations violations = validator.validate(new Password("yavi")); // Invalid ("password" must contain Uppercase policy, "password" must contain at least 1 policies from [Numbers, Symbols])
ConstraintViolations violations = validator.validate(new Password("")); // Invalid ("password" must contain Uppercase policy, "password" must contain Lowercase policy, "password" must contain at least 1 policies from [Numbers, Symbols])
----

|===
|Message Key |Default Message Format |Args

|`charSequence.passwordRequired`
|`"{0}" must contain {1} policy`
a|
* `{0}` ... field name
* `{1}` ... the specified policy name
* `{2}` ... the given value
|`charSequence.passwordOptional`
|`"{0}" must contain at least {1} policies from {2}`
a|
* `{0}` ... field name
* `{1}` ... minimum requirement
* `{2}` ... the specified policy names
* `{3}` ... the given value
|===

Buit-in password policies are following:

* `am.ik.yavi.constraint.password.PasswordPolicy#UPPERCASE`
* `am.ik.yavi.constraint.password.PasswordPolicy#LOWERCASE`
* `am.ik.yavi.constraint.password.PasswordPolicy#NUMBERS`
* `am.ik.yavi.constraint.password.PasswordPolicy#SYMBOLS`

You can define a custom password policy as bellow:

[source,java]
----
PasswordPolicy<String> passwordPolicy = new PasswordPolicy<>() {
	@Override
	public String name() {
		return "DoNotIncludePassword";
	}

	@Override
	public boolean test(String s) {
		return !s.equalsIgnoreCase("password");
	}
};


Validator<Password> validator = ValidatorBuilder.<Password>of()
		.constraint(Password::value, "password", c -> c.password(policy -> policy
				.required(passwordPolicy)
				// ...
				.build()))
		.build();
----

==== `ipv4()`

Check if the target value is a valid IPv4 address

[source,java]
----
Validator<IpAddress> validator = ValidatorBuilder.<IpAddress> of()
        .constraints(IpAddress::value, "ipAddress", c -> c.ipv4())
        .build();

ConstraintViolations violations = validator.validate(new IpAddress("192.0.2.1")); // Valid
ConstraintViolations violations = validator.validate(new IpAddress(null)); // Valid
ConstraintViolations violations = validator.validate(new IpAddress("example.com")); // Invalid ("ipAddress" must not be a valid IPv4)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.ipv4`
|`"{0}" must be a valid IPv4`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `ipv6()`

Check if the target value is a valid IPv6 address

[source,java]
----
Validator<IpAddress> validator = ValidatorBuilder.<IpAddress> of()
        .constraints(IpAddress::value, "ipAddress", c -> c.ipv6())
        .build();

ConstraintViolations violations = validator.validate(new IpAddress("2001:0db8:bd05:01d2:288a:1fc0:0001:10ee")); // Valid
ConstraintViolations violations = validator.validate(new IpAddress(null)); // Valid
ConstraintViolations violations = validator.validate(new IpAddress("192.0.2.1")); // Invalid ("ipAddress" must not be a valid IPv6)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.ipv6`
|`"{0}" must be a valid IPv6`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `url()`

Check if the target value is a valid URL

[source,java]
----
Validator<Url> validator = ValidatorBuilder.<Url> of()
        .constraints(Url::value, "url", c -> c.url())
        .build();

ConstraintViolations violations = validator.validate(new Url("https://yavi.ik.am")); // Valid
ConstraintViolations violations = validator.validate(new Url(null)); // Valid
ConstraintViolations violations = validator.validate(new Url("yavi.ik.am")); // Invalid ("url" must be a valid URL)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.url`
|`"{0}" must be a valid URL`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `luhn()`

Checks if the digits within the target value pass the Luhn checksum algorithm (see also http://en.wikipedia.org/wiki/Luhn_algorithm[Luhn algorithm]).

[source,java]
----
Validator<CreditCard> validator = ValidatorBuilder.<CreditCard> of()
        .constraints(CreditCard::number, "creditCardNumber", c -> c.luhn())
        .build();

ConstraintViolations violations = validator.validate(new CreditCard("4111111111111111")); // Valid
ConstraintViolations violations = validator.validate(new CreditCard(null)); // Valid
ConstraintViolations violations = validator.validate(new CreditCard("4111111111111112")); // Invalid (the check digit for "creditCardNumber" is invalid, Luhn checksum failed)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.luhn`
|`the check digit for "{0}" is invalid, Luhn checksum failed`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isByte()`

Check if the target value can be parsed as a `Byte` value

[source,java]
----
Validator<UserId> validator = ValidatorBuilder.<UserId> of()
        .constraints(UserId::value, "userId", c -> c.isByte())
        .build();

ConstraintViolations violations = validator.validate(UserId.valueOf("127")); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf("a")); // Invalid ("userId" must be a valid representation of a byte.)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.byte`
|`"{0}" must be a valid representation of a byte.`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isShort()`

Check if the target value can be parsed as a `Short` value

[source,java]
----
Validator<UserId> validator = ValidatorBuilder.<UserId> of()
        .constraints(UserId::value, "userId", c -> c.isShort())
        .build();

ConstraintViolations violations = validator.validate(UserId.valueOf("32767")); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf("a")); // Invalid ("userId" must be a valid representation of a short.)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.short`
|`"{0}" must be a valid representation of a short.`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isInteger()`

Check if the target value can be parsed as an `Integer` value

[source,java]
----
Validator<UserId> validator = ValidatorBuilder.<UserId> of()
        .constraints(UserId::value, "userId", c -> c.isInteger())
        .build();

ConstraintViolations violations = validator.validate(UserId.valueOf("2147483647")); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf("a")); // Invalid ("userId" must be a valid representation of an integer.)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.integer`
|`"{0}" must be a valid representation of an integer.`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isLong()`

Check if the target value can be parsed as a `Long` value

[source,java]
----
Validator<UserId> validator = ValidatorBuilder.<UserId> of()
        .constraints(UserId::value, "userId", c -> c.isLong())
        .build();

ConstraintViolations violations = validator.validate(UserId.valueOf("9223372036854775807")); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf("a")); // Invalid ("userId" must be a valid representation of a long.)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.long`
|`"{0}" must be a valid representation of a long.`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isFloat()`

Check if the target value can be parsed as a `Float` value

[source,java]
----
Validator<Money> validator = ValidatorBuilder.<Money> of()
        .constraints(Money::value, "money", c -> c.isFloat())
        .build();

ConstraintViolations violations = validator.validate(Money.valueOf("0.1")); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf("a")); // Invalid ("money" must be a valid representation of a float.)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.float`
|`"{0}" must be a valid representation of a float.`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isDouble()`

Check if the target value can be parsed as a `Double` value

[source,java]
----
Validator<Money> validator = ValidatorBuilder.<Money> of()
        .constraints(Money::value, "money", c -> c.isDouble())
        .build();

ConstraintViolations violations = validator.validate(Money.valueOf("0.1")); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf("a")); // Invalid ("money" must be a valid representation of a double.)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.double`
|`"{0}" must be a valid representation of a double.`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isBigInteger()`

Check if the target value can be parsed as a `BigInteger` value

[source,java]
----
Validator<UserId> validator = ValidatorBuilder.<UserId> of()
        .constraints(UserId::value, "userId", c -> c.isBigInteger())
        .build();

ConstraintViolations violations = validator.validate(UserId.valueOf("127")); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(UserId.valueOf("a")); // Invalid ("userId" must be a valid representation of a big integer.)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.bigInteger`
|`"{0}" must be a valid representation of a big integer.`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isBigDecimal()`

Check if the target value can be parsed as a `BigDecimal` value

[source,java]
----
Validator<Money> validator = ValidatorBuilder.<Money> of()
        .constraints(Money::value, "money", c -> c.isBigDecimal())
        .build();

ConstraintViolations violations = validator.validate(Money.valueOf("50.0")); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf(null)); // Valid
ConstraintViolations violations = validator.validate(Money.valueOf("a")); // Invalid ("money" must be a valid representation of a big decimal.)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.bigDecimal`
|`"{0}" must be a valid representation of a big decimal.`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `codePoints(...)`

Checks if the target value is in the specified set of code points.
Code points can be specified as allowed characters (whitelist) or prohibited characters (blacklist).

A set of code points is represented by `am.ik.yavi.constraint.charsequence.CodePoints` interface, and there is `CodePointsSet` interface that represents the set using `java.util.Set` and `CodePointsRanges` interface that represents a list of code point ranges.

For example, a code point set consisting of "A, B, C, D, a, b, c, d" is expressed as follows:

[source,java]
----
CodePointsSet<String> codePoints = () -> new HashSet<>(
        Arrays.asList(0x0041 /* A */, 0x0042 /* B */, 0x0043 /* C */, 0x0044 /* D */,
                0x0061 /* a */, 0x0062 /* b */, 0x0063 /* c */, 0x0064 /* d */));
----

Or:

[source,java]
----
CodePointsRanges<String> codePoints = () -> Arrays.asList(
        Range.of(0x0041/* A */, 0x0044 /* D */),
        Range.of(0x0061/* a */, 0x0064 /* d */));
----

For consecutive code points, the latter is overwhelmingly more memory efficient.

If you want to regard the code point set as a white list (allowed characters), specify as follows:

[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
        .constraint(Message::getText, "text", c -> c.codePoints(codePoints).asWhiteList())
        .build();

ConstraintViolations violations = validator.validate(new Message("aBCd")); // Valid
ConstraintViolations violations = validator.validate(new Message(null)); // Valid
ConstraintViolations violations = validator.validate(new Message("aBCe")); // Invalid ("[e]" is/are not allowed for "text")
----

If you want to regard the code point set as a blacklist (prohibited characters), specify as follows:

[source,java]
----
Validator<Message> validator = ValidatorBuilder.<Message> of()
        .constraint(Message::getText, "text", c -> c.codePoints(codePoints).asBlackList())
        .build();

ConstraintViolations violations = validator.validate(new Message("hello")); // Valid
ConstraintViolations violations = validator.validate(new Message(null)); // Valid
ConstraintViolations violations = validator.validate(new Message("hallo")); // Invalid ("[a]" is/are not allowed for "text")
----

|===
|Message Key |Default Message Format |Args

|`codePoints.asWhiteList`
|`"{1}" is/are not allowed for "{0}"`
a|
* `{0}` ... field name
* `{1}` ... the violated value
|`codePoints.asBlackList`
|`"{1}" is/are not allowed for "{0}"`
a|
* `{0}` ... field name
* `{1}` ... the violated value
|===

The following is a set of built-in code points.

* `am.ik.yavi.constraint.charsequence.codepoints.AsciiCodePoints#ASCII_PRINTABLE_CHARS` ... ASCII printable characters
* `am.ik.yavi.constraint.charsequence.codepoints.AsciiCodePoints#ASCII_CONTROL_CHARS` ... ASCII control characters
* `am.ik.yavi.constraint.charsequence.codepoints.AsciiCodePoints#CRLF` ... `0x000A` (LINE FEED) and `0x000D` (CARRIAGE RETURN)
* `am.ik.yavi.constraint.charsequence.codepoints.UnicodeCodePoints#HIRAGANA` ... https://www.unicode.org/charts/nameslist/c_3040.html[Hiragana] defined in Unicode (different from JIS X 0208 definition)
* `am.ik.yavi.constraint.charsequence.codepoints.UnicodeCodePoints#KATAKANA` ... https://www.unicode.org/charts/nameslist/c_30A0.html[Katakana] and https://www.unicode.org/charts/nameslist/c_31F0.html[Katakana Phonetic Extensions] defined in Unicode (different from JIS X 0208 definition)

You can also represent the union of multiple code point sets with `am.ik.yavi.constraint.charsequence.codepoints.CompositeCodePoints` class.

==== `normalizer(Normalizer.Form)`

==== `variant(...)`

==== `asByteArray()`

==== `emoji()`

=== Integer/Short/Long/Charactor/Byte/Float/Long

=== BigInteger/BigDecimal

=== Boolean

=== Object

=== List/Array/Map