[[built-in-constraints]]
== Built-in Constraints

YAVI includes many commonly used built-in constraints for various types.

=== String

==== `notNull()`

Checks that the target value is not `null`

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.notNull())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Invalid ("email" must not be null)
----

|===
|Message Key |Default Message Format |Args

|`object.notNull`
|`"{0}" must not be null`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `notEmpty()`

Checks whether the target value is not `null` nor empty

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.notEmpty())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Invalid ("email" must not be empty)
ConstraintViolations violations = validator.validate(new Email("")); // Invalid ("email" must not be empty)
----

|===
|Message Key |Default Message Format |Args

|`container.notEmpty`
|`"{0}" must not be empty`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `notBlank()`

Checks that the target value is not `null`, and the trimmed length is greater than `0`.
The difference to `notEmpty()` is that trailing white-spaces are ignored.

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.notBlank())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Invalid ("email" must not be blank)
ConstraintViolations violations = validator.validate(new Email(" ")); // Invalid ("email" must not be blank)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.notBlank`
|`"{0}" must not be blank`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `fixedSize(int)`

Checks if the target value's size is the specified size

[source,java]
----
Validator<ZipCode> validator = ValidatorBuilder.<ZipCode> of()
        .constraints(ZipCode::value, "zipCode", c -> c.fixedSize(7))
        .build();

ConstraintViolations violations = validator.validate(new ZipCode("1234567")); // Valid
ConstraintViolations violations = validator.validate(new ZipCode(null)); // Valid
ConstraintViolations violations = validator.validate(new ZipCode("123-4567")); // Invalid (The size of "zipCode" must be 7. The given size is 8)
----

|===
|Message Key |Default Message Format |Args

|`container.fixedSize`
|`The size of "{0}" must be {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `greaterThan(int)`

Checks if the target value's size is greater than the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.greaterThan(2))
        .build();

ConstraintViolations violations = validator.validate(new Country("Japan")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("J")); // Invalid (The size of "country" must be greater than 2. The given size is 1)
----

|===
|Message Key |Default Message Format |Args

|`container.greaterThan`
|`The size of "{0}" must be greater than {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `greaterThanOrEqual(int)`

Checks if the target value's size is greater than or equals to the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.greaterThanOrEqual(2))
        .build();

ConstraintViolations violations = validator.validate(new Country("Japan")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("J")); // Invalid (The size of "country" must be greater than or equal to 2. The given size is 1)
----

|===
|Message Key |Default Message Format |Args

|`container.greaterThanOrEqual`
|`The size of "{0}" must be greater than or equal to {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `lessThan(int)`

Checks if the target value's size is less than the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.lessThan(4))
        .build();

ConstraintViolations violations = validator.validate(new Country("JP")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("Japan")); // Invalid (The size of "country" must be less than 4. The given size is 5)
----

|===
|Message Key |Default Message Format |Args

|`container.lessThan`
|`The size of "{0}" must be less than {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `lessThanOrEqual(int)`

Checks if the target value's size is less than or equals to the specified size

[source,java]
----
Validator<Country> validator = ValidatorBuilder.<Country> of()
        .constraints(Country::value, "country", c -> c.lessThanOrEqual(4))
        .build();

ConstraintViolations violations = validator.validate(new Country("JP")); // Valid
ConstraintViolations violations = validator.validate(new Country(null)); // Valid
ConstraintViolations violations = validator.validate(new Country("Japan")); // Invalid (The size of "country" must be less than or equal to to 4. The given size is 5)
----

|===
|Message Key |Default Message Format |Args

|`container.lessThanOrEqual`
|`The size of "{0}" must be less than or equal to {1}. The given size is {2}`
a|
* `{0}` ... field name
* `{1}` ... the specified size
* `{2}` ... the given size
* `{3}` ... the given value
|===

==== `contains(CharSequence)`

Checks if the target value contains the specified sequence of char values

[source,java]
----
Validator<ZipCode> validator = ValidatorBuilder.<ZipCode> of()
        .constraints(ZipCode::value, "zipCode", c -> c.contains("-"))
        .build();

ConstraintViolations violations = validator.validate(new ZipCode("123-4567")); // Valid
ConstraintViolations violations = validator.validate(new ZipCode(null)); // Valid
ConstraintViolations violations = validator.validate(new ZipCode("1234567")); // Invalid ("zipCode" must contain -)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.contains`
|`"{0}" must contain {1}`
a|
* `{0}` ... field name
* `{1}` ... the specified char sequence
* `{2}` ... the given value
|===

==== `pattern(String)`

Checks if the target value matches the specified regular expression

[source,java]
----
Validator<ZipCode> validator = ValidatorBuilder.<ZipCode> of()
        .constraints(ZipCode::value, "zipCode", c -> c.pattern("[0-9]{3}-[0-9]{4}"))
        .build();

ConstraintViolations violations = validator.validate(new ZipCode("123-4567")); // Valid
ConstraintViolations violations = validator.validate(new ZipCode(null)); // Valid
ConstraintViolations violations = validator.validate(new ZipCode("1234567")); // Invalid ("zipCode" must match [0-9]{3}-[0-9]{4})
----

|===
|Message Key |Default Message Format |Args

|`charSequence.pattern`
|`"{0}" must match {1}`
a|
* `{0}` ... field name
* `{1}` ... the specified regular expression
* `{2}` ... the given value
|===

==== `email()`

Checks if the target value is a valid email address

[source,java]
----
Validator<Email> validator = ValidatorBuilder.<Email> of()
        .constraints(Email::value, "email", c -> c.email())
        .build();

ConstraintViolations violations = validator.validate(new Email("yavi@example.com")); // Valid
ConstraintViolations violations = validator.validate(new Email(null)); // Valid
ConstraintViolations violations = validator.validate(new Email("example.com")); // Invalid ("email" must not be a valid email address)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.email`
|`"{0}" must match {1}`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `password(...)`

Check if the target value meets the specified password policy

[source,java]
----
Validator<Password> validator = ValidatorBuilder.<Password>of()
		.constraint(Password::value, "password", c -> c.password(policy -> policy
				.uppercase()
				.lowercase()
				// or .required(PasswordPolicy.UPPERCASE, PasswordPolicy.LOWERCASE)
				.optional(1, PasswordPolicy.NUMBERS, PasswordPolicy.SYMBOLS)
				.build()))
		.build();

ConstraintViolations violations = validator.validate(new Password("Yavi123")); // Valid
ConstraintViolations violations = validator.validate(new Password(null)); // Valid
ConstraintViolations violations = validator.validate(new Password("yavi123")); // Invalid ("password" must contain Uppercase policy)
ConstraintViolations violations = validator.validate(new Password("yavi")); // Invalid ("password" must contain Uppercase policy, "password" must contain at least 1 policies from [Numbers, Symbols])
ConstraintViolations violations = validator.validate(new Password("")); // Invalid ("password" must contain Uppercase policy, "password" must contain Lowercase policy, "password" must contain at least 1 policies from [Numbers, Symbols])
----

|===
|Message Key |Default Message Format |Args

|`charSequence.passwordRequired`
|`"{0}" must contain {1} policy`
a|
* `{0}` ... field name
* `{1}` ... the specified policy name
* `{2}` ... the given value
|`charSequence.passwordOptional`
|`"{0}" must contain at least {1} policies from {2}`
a|
* `{0}` ... field name
* `{1}` ... minimum requirement
* `{2}` ... the specified policy names
* `{3}` ... the given value
|===

Buit-in password policies are following:

* `am.ik.yavi.constraint.password.PasswordPolicy#UPPERCASE`
* `am.ik.yavi.constraint.password.PasswordPolicy#LOWERCASE`
* `am.ik.yavi.constraint.password.PasswordPolicy#NUMBERS`
* `am.ik.yavi.constraint.password.PasswordPolicy#SYMBOLS`

You can define a custom password policy as bellow:

[source,java]
----
PasswordPolicy<String> passwordPolicy = new PasswordPolicy<>() {
	@Override
	public String name() {
		return "DoNotIncludePassword";
	}

	@Override
	public boolean test(String s) {
		return !s.equalsIgnoreCase("password");
	}
};


Validator<Password> validator = ValidatorBuilder.<Password>of()
		.constraint(Password::value, "password", c -> c.password(policy -> policy
				.required(passwordPolicy)
				// ...
				.build()))
		.build();
----

==== `ipv4()`

Check if the target value is a valid IPv4 address

[source,java]
----
Validator<IpAddress> validator = ValidatorBuilder.<IpAddress> of()
        .constraints(IpAddress::value, "ipAddress", c -> c.ipv4())
        .build();

ConstraintViolations violations = validator.validate(new IpAddress("192.0.2.1")); // Valid
ConstraintViolations violations = validator.validate(new IpAddress(null)); // Valid
ConstraintViolations violations = validator.validate(new IpAddress("example.com")); // Invalid ("ipAddress" must not be a valid IPv4)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.ipv4`
|`"{0}" must be a valid IPv4`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `ipv6()`

Check if the target value is a valid IPv6 address

[source,java]
----
Validator<IpAddress> validator = ValidatorBuilder.<IpAddress> of()
        .constraints(IpAddress::value, "ipAddress", c -> c.ipv6())
        .build();

ConstraintViolations violations = validator.validate(new IpAddress("2001:0db8:bd05:01d2:288a:1fc0:0001:10ee")); // Valid
ConstraintViolations violations = validator.validate(new IpAddress(null)); // Valid
ConstraintViolations violations = validator.validate(new IpAddress("192.0.2.1")); // Invalid ("ipAddress" must not be a valid IPv4)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.ipv6`
|`"{0}" must be a valid IPv6`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `url()`

Check if the target value is a valid URL

[source,java]
----
Validator<Url> validator = ValidatorBuilder.<Url> of()
        .constraints(Url::value, "url", c -> c.url())
        .build();

ConstraintViolations violations = validator.validate(new Url("https://yavi.ik.am")); // Valid
ConstraintViolations violations = validator.validate(new Url(null)); // Valid
ConstraintViolations violations = validator.validate(new Url("yavi.ik.am")); // Invalid ("url" must be a valid URL)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.url`
|`"{0}" must be a valid URL`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `luhn()`

Checks if the digits within the target value pass the Luhn checksum algorithm (see also http://en.wikipedia.org/wiki/Luhn_algorithm[Luhn algorithm]).

[source,java]
----
Validator<CreditCard> validator = ValidatorBuilder.<CreditCard> of()
        .constraints(CreditCard::number, "creditCardNumber", c -> c.luhn())
        .build();

ConstraintViolations violations = validator.validate(new Url("4111111111111111")); // Valid
ConstraintViolations violations = validator.validate(new Url(null)); // Valid
ConstraintViolations violations = validator.validate(new Url("4111111111111112")); // Invalid (the check digit for "creditCardNumber" is invalid, Luhn checksum failed)
----

|===
|Message Key |Default Message Format |Args

|`charSequence.luhn`
|`the check digit for "{0}" is invalid, Luhn checksum failed`
a|
* `{0}` ... field name
* `{1}` ... the given value
|===

==== `isByte()`

Check if the target value can be parsed as a `Byte` value

==== `isShort()`

Check if the target value can be parsed as a `Short` value

==== `isInteger()`

Check if the target value can be parsed as an `Integer` value

==== `isLong()`

Check if the target value can be parsed as a `Long` value

==== `isFloat()`

Check if the target value can be parsed as a `Float` value

==== `isDouble()`

Check if the target value can be parsed as a `Double` value

==== `isBigInteger()`

Check if the target value can be parsed as a `BigInteger` value

==== `isBigDecimal()`

Check if the target value can be parsed as a `BigDecimal` value

==== `codePoints(...)`

==== `normalizer(Normalizer.Form)`

==== `variant(...)`

==== `asByteArray()`

==== `emoji()`

=== Integer/Short/Long/Charactor/Byte/Float/Long

=== BigInteger/BigDecimal

=== Boolean

=== Object

=== List/Array/Map