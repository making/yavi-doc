[[core-features]]
== Core Features

=== Define and obtain a core `Validator` instance

The core validator `am.ik.yavi.core.Validator` can be defined and obtained via `am.ik.yavi.builder.ValidatorBuilder`.
Here is an example:

[source,java]
----
Validator<User> validator = ValidatorBuilder.<User> of() // or ValidatorBuilder.of(User.class)
    .constraint(User::getName, "name", c -> c.notNull()
        .lessThanOrEqual(20))
    .constraint(User::getEmail, "email", c -> c.notNull()
        .greaterThanOrEqual(5)
        .lessThanOrEqual(50)
        .email())
    .constraint(User::getAge, "age", c -> c.notNull()
        .greaterThanOrEqual(0)
        .lessThanOrEqual(200))
    .build();

ConstraintViolations violations = validator.validate(user);
violations.isValid(); // true or false
violations.forEach(x -> System.out.println(x.message()));
----

See <<built-in-constraints>> for other constraint rules.

=== Constraints on nested objects

You can use `nested` method to apply constraints to the nested fields.
You can delegate to the `Validator` for the nested field, or you can also define a set of constraints on the nested field inside.

[source,java]
----
public class Address {
    private Country country;
    private City city;
    // Omits other fields and getters
}

Validator<Country> countryValidator = ValidatorBuilder.<Country> of()
    .nest(Country::getName, "name", c -> c.notBlank().lessThanOrEqual(20))
    .build();
Validator<City> cityValidator = ValidatorBuilder.<City> of()
    .nest(City::getName, "name", c -> c.notBlank().lessThanOrEqual(100))
    .build();

Validator<Address> validator = ValidatorBuilder.<Address> of()
    .nest(Address::getCountry, "country", countryValidator)
    .nest(Address::getCity, "city", cityValidator)
    .build();
----

Or:

[source,java]
----
Validator<Address> validator = ValidatorBuilder.<Address> of()
      .nest(Address::getCountry, "country",
            b -> b.constraint(Country::getName, "name", c -> c.notBlank().lessThanOrEqual(20)))
      .nest(Address::getCity, "city",
            b -> b.constraint(City::getName, "name", c -> c.notBlank().lessThanOrEqual(100)))
      .build();
----

=== Overriding violation messages

The default violation message for each constraint is defined in <<built-in-constraints>>.

If you want to customize the violation message, add `message` method on the target constraint as follows:

[source,java]
----
Validator<User> validator = ValidatorBuilder.<User> of()
    .constraint(User::getName, "name", c -> c.notNull().message("name is required!")
        .greaterThanOrEqual(1).message("name is too small!")
        .lessThanOrEqual(20).message("name is too large!"))
    .build()
----

=== Kotlin Support

If you are using Kotlin, you can define a `Validator` a bit shorter than Java using `konstraint` method instead of `constraint` as follows:

[source,kotlin]
----
val validator: Validator<User> = ValidatorBuilder.of<User>()
    .konstraint(User::name) {
        notNull()
            .lessThanOrEqual(20)
    }
    .konstraint(User::email) {
        notNull()
            .greaterThanOrEqual(5)
            .lessThanOrEqual(50)
            .email()
    }
    .konstraint(User::age) {
        notNull()
            .greaterThanOrEqual(0)
            .lessThanOrEqual(200)
    }
    .build()
----

NOTE: `konstraint` actually uses `kotlin.reflect.KProperty1` ðŸ¤«