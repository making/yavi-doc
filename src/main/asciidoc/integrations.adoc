[[integrations]]
== Integrations

Although YAVI doesn't depend on anything, it has interfaces that magically fit into Framework.

=== Integration with `BindingResult` in Spring MVC

`ConstraintViolations#apply` accepts the Function Interface with the same arguments as Spring Framework's `BindingResult#rejectValue` method and passes the violation messages.

To reflect validation results by YAVI in a Controller of Spring MVC, you can write the following code.

[source,java]
----
final Validator<UserForm> validator = ...;

@PostMapping(path = "users")
public String createUser(Model model, UserForm userForm, BindingResult bindingResult) {
    ConstraintViolations violations = validator.validate(userForm);
    if (!violations.isValid()) {
        violations.apply(BindingResult::rejectValue);
        return "userForm";
    }
    // ...
    return "redirect:/";
}
----

If you like the functional way, you can also write:

[source,java]
----
final Validator<UserForm> validator = ...;

@PostMapping(path = "users")
public String createUser(Model model, UserForm userForm, BindingResult bindingResult) {
    return validator.applicative()
        .validate(userForm)
        .fold(violations -> {
            ConstraintViolations.of(violations).apply(BindingResult::rejectValue);
            return "userForm";
        }, form -> {
            // ...
            return "redirect:/";
        });
}
----

TIP: `List<ContraintViolation>` is passed to the function of the first argument of `Validated#fold` instead of `ConstraintViolations`. You can convert the `List<ContraintViolation>` to `ConstraintViolations` by using the `ConstraintViolations#of` method.

=== Converting `ConstraintViolations` to the format to serialize as a response body

`ConstraintViolation` is not suitable for serializing with a serializer like Jackson. Instead, you can use `ConstraintViolation#detail` method to convert it to a `ViolationDetail` object that is easy to serialize.

The `ConstraintViolations#details` method translates all `ConstraintViolation` s and returns `List<ViolationDetail>`.

[source,java]
----
final Validator<UserCreateRequest> validator = ...;

@PostMapping(path = "users")
public ResponseEntity<?> createUser(@RequestBody UserCreateRequest request) {
    ConstraintViolations violations = validator.validate(request);
    if (violations.isValid()) {
        User created = userService.create(request.toUser());
        return ResponseEntity.ok(created);
    } else {
        return ResponseEntity.badRequest().body(violations.details());
    }
}
----

If you like the functional way, you can also write:

[source,java]
----
final Validator<UserCreateRequest> validator = ...;

@PostMapping(path = "users")
public ResponseEntity<?> createUser(@RequestBody UserCreateRequest request) {
    return validator.applicative()
        .validate(request)
        .map(req -> userService.create(req.toUser()))
        .mapErrors(violations -> ConstraintViolations.of(violations).details())
        // or .mapErrorsF(ConstraintViolation::detail)
        .fold(details -> ResponseEntity.badRequest().body(Map.of("message", "Invalid request body", "details", details)),
            created -> ResponseEntity.ok(created));
}
----

TIP: `ViolationDetail` works with GraalVM native image out of the box.

=== Integration with Spring WebFlux.fn

YAVI will be a great fit for https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-fn[Spring WebFlux.fn].

[source,java]
----
final Validator<UserCreateRequest> validator = ...;

public RouterFunction<ServerResponse> routes() {
    return RouterFunctions.route()
        .POST("/users", request -> request.bodyToMono(UserCreateRequest.class)
            .flatMap(body -> validator.applicative()
                .validate(body)
                .map(req -> userService.create(req.toUser()))
                .mapErrors(violations -> ConstraintViolations.of(violations).details())
                // or .mapErrorsF(ConstraintViolation::detail)
                .fold(details -> ServerResponse.badRequest().bodyValue(Map.of("message", "Invalid request body", "details", details)),
                    created -> ServerResponse.ok().bodyValue(created))))
        .build();
}
----

TIP: YAVI was originally developed as a validator naturally fit with Spring WebFlux.fn.

=== Integration with `MessageSource` in Spring Framework


`am.ik.yavi.message.MessageSourceMessageFormatter` accepts the Functional Interface with the same arguments as Spring Framework's `MessageSource#getMessage`.
This allows you to delegate control of the message format of violation messages to Spring Framework.

`MessageSourceMessageFormatter` can be used as follows:

[source,java]
----
@RestController
public class OrderController {
    private final Validator<CartItem> validator;

    public OrderController(MessageSource messageSource) {
    	MessageFormatter messageFormatter = new MessageSourceMessageFormatter(messageSource::getMessage);
        this.validator = ValidatorBuilder.<CartItem> of()
            .constraints(...)
            .messageFormatter(messageFormatter)
            .build();
    }
}
----


