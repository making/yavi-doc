[[using-yavi]]
== Using YAVI

This section describes the basic usage of YAVI.

=== Define and obtain a core `Validator` instance

The core validator `am.ik.yavi.core.Validator` can be defined and obtained via `am.ik.yavi.builder.ValidatorBuilder`.
Here is an example:

[source,java]
----
Validator<User> validator = ValidatorBuilder.<User> of() // or ValidatorBuilder.of(User.class)
    .constraint(User::getName, "name", c -> c.notNull().lessThanOrEqual(20))
    .constraint(User::getEmail, "email", c -> c.notNull().greaterThanOrEqual(5).lessThanOrEqual(50).email())
    .constraint(User::getAge, "age", c -> c.notNull().greaterThanOrEqual(0).lessThanOrEqual(200))
    .build();

ConstraintViolations violations = validator.validate(user);
violations.isValid(); // true or false
violations.forEach(x -> System.out.println(x.message()));
----

In order to avoid ambiguous type inferences, you can use explicit `_<type>` method per type instead of constraint as follows:

[source,java]
----
Validator<User> validator = ValidatorBuilder.<User> of()
    ._string(User::getName, "name", c -> c.notNull().lessThanOrEqual(20))
    ._string(User::getEmail, "email", c -> c.notNull().greaterThanOrEqual(5).lessThanOrEqual(50).email())
    ._integer(User::getAge, "age", c -> c.notNull().greaterThanOrEqual(0).lessThanOrEqual(200))
    .build();
----

The first argument of the `constraint` method does not have to be a "Getter" as long as it is a `java.util.function.Function`.

For example, If you want to create a `Validator` for https://openjdk.java.net/jeps/395[Records], you can implement it straightforwardly like bellow:

[source,java]
----
public record User(String name, String email, int age) {
}

Validator<User> validator = ValidatorBuilder.<User> of() // or ValidatorBuilder.of(User.class)
    .constraint(User::name, "name", c -> c.notNull().lessThanOrEqual(20))
    // Omits others
    .build();
----

Or if you don't want your method to expose the target field, you can define the contraint like follwing:

[source,java]
----
public class User {
    private final String name;

    public final Validator<User> validator = ValidatorBuilder.<User>of()
        ._string(x -> x.name, "name", c -> c.notNull().lessThanOrEqual(20))
        .build();

    public User(String name) {
        this.name = name;
    }
    // Omits others
}
----

See <<built-in-constraints>> for other constraint rules.

=== Constraints on nested objects

You can use `nest` method to apply constraints to the nested fields.
You can delegate to the `Validator` for the nested field, or you can also define a set of constraints on the nested field inside.

[source,java]
----
public class Address {
    private Country country;
    private City city;
    // Omits other fields and getters
}

Validator<Country> countryValidator = ValidatorBuilder.<Country> of()
    .nest(Country::getName, "name", c -> c.notBlank().lessThanOrEqual(20))
    .build();
Validator<City> cityValidator = ValidatorBuilder.<City> of()
    .nest(City::getName, "name", c -> c.notBlank().lessThanOrEqual(100))
    .build();

Validator<Address> validator = ValidatorBuilder.<Address> of()
    .nest(Address::getCountry, "country", countryValidator)
    .nest(Address::getCity, "city", cityValidator)
    .build();
----

Or:

[source,java]
----
Validator<Address> validator = ValidatorBuilder.<Address> of()
      .nest(Address::getCountry, "country",
            b -> b.constraint(Country::getName, "name", c -> c.notBlank().lessThanOrEqual(20)))
      .nest(Address::getCity, "city",
            b -> b.constraint(City::getName, "name", c -> c.notBlank().lessThanOrEqual(100)))
      .build();
----

=== Overriding violation messages

The default violation message for each constraint is defined in <<built-in-constraints>>.

If you want to customize the violation message, append `message` method on the target constraint as follows:

[source,java]
----
Validator<User> validator = ValidatorBuilder.<User> of()
    .constraint(User::getName, "name", c -> c.notNull().message("name is required!")
        .greaterThanOrEqual(1).message("name is too small!")
        .lessThanOrEqual(20).message("name is too large!"))
    .build()
----

=== Creating a custom constraint

If you want to apply constraints that are not in the <<built-in-constraints>>, you can create custom constraints by implementing `am.ik.yavi.core.CustomConstraint` interface as bellow:

[source,java]
----
public class IsbnConstraint implements CustomConstraint<String> {

    @Override
    public boolean test(String s) {
        // Delegate processing to another method
        return ISBNValidator.isISBN13(s);
    }

    @Override
    public String messageKey() {
        return "string.isbn13";
    }

    @Override
    public String defaultMessageFormat() {
        return "\"{0}\" must be ISBN13 format";
    }
}
----

The created custom constraint can be specified by `predicate` method as follows:

[source,java]
----
IsbnConstraint isbn = new IsbnConstraint();
Validator<Book> book = ValidatorBuilder.<Book> of()
    .constraint(Book::getTitle, "title", c -> c.notBlank().lessThanOrEqual(64))
    .constraint(Book::getIsbn, "isbn", c -> c.notBlank().predicate(isbn))
    .build();
----

You can also write constraint rules directly in the `predicate` method instead of defining the `CustomConstraint` class.

[source,java]
----
Validator<Book> book = ValidatorBuilder.<Book> of()
    .constraint(Book::getTitle, "title", c -> c.notBlank().lessThanOrEqual(64))
    .constraint(Book::getIsbn, "isbn", c -> c.notBlank().predicate(s -> ISBNValidator.isISBN13(s), ViolationMessage.of("string.isbn13", "\"{0}\" must be ISBN13 format")))
    .build();
----

The first argument of the violation message is the field name. Also, the last argument is the violated value.

If you want to use other arguments, override `arguments` method as bellow:

[source,java]
----
public class InstantRangeConstraint implements CustomConstraint<Instant> {

    private final Instant end;

    private final Instant start;

    InstantRangeConstraint(Instant start, Instant end) {
        this.start = Objects.requireNonNull(start);
        this.end = Objects.requireNonNull(end);
    }

    @Override
    public Object[] arguments() {
        return new Object[] { this.start /* {1} */, this.end /* {2} */};
    }

    @Override
    public String defaultMessageFormat() {
        return "Instant value \"{0}\" must be between \"{1}\" and \"{2}\".";
    }

    @Override
    public String messageKey() {
        return "instant.range";
    }

    @Override
    public boolean test(Instant instant) {
        return instant.isAfter(this.start) && instant.isBefore(this.end);
    }
}
----

[[cross-field-validation]]
=== Cross-field validation

If you want to apply constraints on target class itself, you can use `constraintOnTarget`.
It can be used when you want to apply cross-field constraints as follows:

[source,java]
----
Validator<Range> validator = ValidatorBuilder.<Range> of()
    .constraint(range::getFrom, "from", c -> c.greaterThan(0))
    .constraint(range::getTo, "to", c -> c.greaterThan(0))
    .constraintOnTarget(range -> range.getTo() > range.getFrom(), "to", "to.isGreaterThanFrom", "\"to\" must be greater than \"from\"")
    .build();
----

You can also create a custom constraint for the cross-field validation as follows:

[source,java]
----
public class RangeConstraint implements CustomConstraint<Range> {
    @Override
    public String defaultMessageFormat() {
        return "\"to\" must be greater than \"from\"";
    }

    @Override
    public String messageKey() {
        return "to.isGreaterThanFrom";
    }

    @Override
    public boolean test(Range range) {
        return range.getTo() > range.getFrom();
    }
}

RangeConstraint range = new RangeConstraint();
Validator<Range> validator = ValidatorBuilder.<Range>of()
        .constraintOnTarget(range, "to")
        .build();
----
=== Kotlin Support

If you are using Kotlin, you can define a `Validator` a bit shorter than Java using `konstraint` method instead of `constraint` as follows:

[source,kotlin]
----
val validator: Validator<User> = ValidatorBuilder.of<User>()
    .konstraint(User::name) {
        notNull()
            .lessThanOrEqual(20)
    }
    .konstraint(User::email) {
        notNull()
            .greaterThanOrEqual(5)
            .lessThanOrEqual(50)
            .email()
    }
    .konstraint(User::age) {
        notNull()
            .greaterThanOrEqual(0)
            .lessThanOrEqual(200)
    }
    .build()
----

NOTE: `konstraint` actually uses `kotlin.reflect.KProperty1` ðŸ¤«